<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>🔱The Wall of Eddix</title>
    <link>http://eddix.me/</link>
    <description>Recent content on 🔱The Wall of Eddix</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 18 Sep 2020 15:20:09 +0800</lastBuildDate><atom:link href="http://eddix.me/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Go]设置各种选项的最佳套路</title>
      <link>http://eddix.me/posts/option-types-pattern/</link>
      <pubDate>Fri, 18 Sep 2020 15:20:09 +0800</pubDate>
      
      <guid>http://eddix.me/posts/option-types-pattern/</guid>
      <description>背景 在 Go 里面写一个 struct 时，经常会遇到要给 struct 里面的各个字段提供设置功能。这个问题看起来很简单很容易，实际上困扰了不少人，连 Go 的三巨头之一 Rob Pike 都曾经为之苦恼了一段时间，后来找到了最佳实践后还为此开心地写了一篇 Blog。
我最早是在 GRPC 的代码里发现这个套路的，后来在今年7月 Go 官方 Blog 里又看到了对这个套路的推荐，以及 Rob Pike 的 Blog 链接。我自己在代码里尝试之后感觉很好，又推荐给同事尝试，大家都很喜欢。
示范案例 我用这样一个需求案例来对比一下各种套路的优劣。
我们要写一个 struct，它的核心功能是创建一个网络连接 net.Conn 的实例，也就是实现下面这个方法：
type MyDialer struct { dialer *net.Dialer } func (d *MyDialer) DialContext(ctx context.Context, addr net.Addr) (net.Conn, error) { return d.dialer.DialContext(ctx, addr.Network(), addr.String()) } 针对这个 Dialer ，我们增加两个选项，一个是连接超时，一个是重试次数。代码就变成了这样：
type MyDialer struct { dialer *net.Dialer timeout time.Duration retry int } func (d *MyDialer) DialContext(ctx context.</description>
    </item>
    
    <item>
      <title>[Go] 写一个守护协程的通用套路是什么？</title>
      <link>http://eddix.me/posts/pattern-of-daemon-goroutine/</link>
      <pubDate>Tue, 02 Jun 2020 12:09:34 +0800</pubDate>
      
      <guid>http://eddix.me/posts/pattern-of-daemon-goroutine/</guid>
      <description>背景 根据一个 Goroutine 是否直接依赖用户交互，我们可以将 Goroutine 分为两大类，一类是直接依赖用户交互的前台协程，比如 HTTP Server Handler等；另一类是不直接依赖用户交互的后台协程，比如 HTTP Server，定时任务协程等。前台协程随用户的交互开始执行，随交互结束而结束，比较容易设计。本文主要讨论后台协程设计的一些通用套路。
一个良好的后台协程需要至少满足以下两个诉求：
 容易控制，尤其是启动、停止、重启等操作。 状态容易被观察，比如是否正在运行中。  针对这两个诉求，我们来寻找一个通用的实现套路。
设计与实现 简陋的后台协程 得益于 Go 从语法上对并发的支持，写一个简陋的后台协程再简单不过了。我们从下面这个 Demo 开始讨论，这个 Demo 的任务很简单，每隔一秒钟将下一个斐波那契数输出在标准输出里面。
package main type Fibonacci struct { a, b int } func NewFibonacci() *Fibonacci { return &amp;amp;Fibonacci{a:0, b:1} } func (f *Fibonacci) Run() { go func() { for { time.Sleep(time.Second) fmt.Println(f.b) f.a, f.b = f.b, f.a + f.b } }() } func main() { NewFibonacci().Run() } 直接执行这个程序，什么都不会输出，因为主协程里面没有任何逻辑执行，程序启动后直接就退出了，对吧？不过现实中许多后台协程就是这样写的，因为真实世界里很多主协程是有其它任务在执行的，所以 Fibonacci 会一直执行下去，直到程序结束。</description>
    </item>
    
    <item>
      <title>😷About this wall</title>
      <link>http://eddix.me/about/</link>
      <pubDate>Sun, 02 Feb 2020 18:26:32 +0800</pubDate>
      
      <guid>http://eddix.me/about/</guid>
      <description>这个也不算什么个人博客，毕竟写博客已经是十几年前的行为了。这里只是随便放点杂货。</description>
    </item>
    
    <item>
      <title>[转载] 开源代码的范式转移</title>
      <link>http://eddix.me/posts/paradigm-shift-of-open-source/</link>
      <pubDate>Fri, 28 Jun 2019 19:21:50 +0800</pubDate>
      
      <guid>http://eddix.me/posts/paradigm-shift-of-open-source/</guid>
      <description>💡 这篇文章是 Tim O&amp;rsquo;Reilly 的演讲稿。我最早是在字节社上看到这篇文章的，后来字节社下架，电子书文件被我导出来放到了其它阅读器上。 这篇文章深入分析了开源代码的价值链，对于理解软件工作的价值非常有启发。
 🗓2004年6月
这篇文章是基于我2003年5月在华平投资集团（Warburg-Pincus）的年度技术会议上的演讲。之后，我已经就此做过超过20次不同版本的演讲，足迹踏遍O’Reilly开放源码大会、英国Unix用户组、英国微软研究院、IBM赫斯利实验室、英国电信、Red Hat的内部「全体」会议，以及BEA的eWorld大会。最后，为了一本即将出版的关于开源的书籍《免费和开放源码的前景》，我将此演讲写成了文字。此书由J. Feller, B. Fitzgerald, S. Hissan，以及K.R. Lakhani编辑，将由麻省理工学院出版社在2005年出版。
1962年，Thomas Kuhn出版了一本突破性的书，叫做《科学革命的结构》。在书中，他提出科学的发展不是渐进的，而是（像今天我们认为生物进化那样）一种间断平衡（Punctuated Equilibrium），其中有很多划时代变革的时刻。当哥白尼提出行星围绕太阳而不是地球运动的假说来解释行星运动的时候，或者当达尔文提出物种起源的想法的时候，他们所做的超越了仅是在过去的发现上有所创造，或是解释新的实验数据。Kuhn指出，一个真正深刻的科学突破，「很少是，或根本不是在已知之上的增量。吸收他们需要对之前的理论进行重构，并对之前的事实进行重新评价。这个从本质上就很革命性的过程很少能够被一个人完成，一夜之间更是不可能。」
Kuhn把这些科学中的革命性过程称作「范式转移」，这个术语现在用来描述在我们参考系中的一切深刻变化。
范式转移在商业中和在科学中都经常发生。就像科学革命一样，它们也要经历复杂的斗争，其下隐含的观念要在提出很久后才被广泛接受。更重要的是，它们的深刻意义通常远超过其创造者的理解。
一个范式转移就发生在1981年引入IBM个人电脑标准化体系结构的时候。和之前的工业实践大相径庭，IBM选择用市面上的现成部件来建造自己的计算机，并公开其设计以便其他制造商复制。结果，IBM个人电脑体系结构成为了标准，随着时间演进，它们不仅取代了其它个人电脑设计，后来二十年里还取代了小型机和大型机。
然而，IBM的经理们却没能理解他们的决策的全部后果。当时，IBM在计算机市场上的份额远超过微软公司在今天的桌面操作系统市场上的统治地位。软件只是当时计算机产业的一小部分，是一台集成的计算机的不可缺少的部分，常常被捆绑销售而非单独销售。很明显，当时的独立软件公司都是围绕着它们选定的硬件平台而生产。所以到了要给一台新机器提供操作系统的时候，IBM决定从一家叫做微软的小公司获得许可，把在不受自己控制的一小部分市场上出售软件的权利让了出去。随着上千家大大小小的制造商开始克隆个人电脑，IBM丧失了在新市场里面的领袖地位。软件成为了整个行业围绕转动的新的太阳；微软，而不是IBM，成为了计算机产业中最重要的公司。
但这不是这个故事给我们上的唯一一课。在最初的争取个人电脑市场领袖地位的竞争中，各个公司争相「改进」个人电脑标准，增加对新的周边设备、更快的总线、以及对其它专有技术创新的支持，经理们在之前由硬件主导的计算机产业中接受了训练，从旧的范式得来的经验教训指导着他们的行动。
其中最不妥协者，比如Digital的Ken Olson，嘲笑说PC不过是一个玩具，并拒绝进入市场，直到为时已晚。但是即使像康柏这样的先行者──它的早期成功源于发明「可打包（luggable）」计算机，也就是今天的笔记本的祖先──也被那些在新的范式下不再适用的旧经验误导。最后还是得靠一个外来者，Michael Dell（迈克尔·戴尔）──他的公司是从大学宿舍里面邮购销售电脑开始的──来意识到标准化的PC是一种商品，市场优势并不是来自于制造更好的电脑，而是制造足够好的电脑，并通过全力贴近市场标准来降低生产成本，并在市场、铺货、以及后勤等领域寻找优势。最后，是戴尔，而不是IBM或者康柏，成为了最大的PC硬件制造商。
同一时刻，Intel，另一家在新的商品平台上豪赌了一把的公司，放弃了它认为站不住脚的内存芯片业务，全力争当新的设计中的更复杂的大脑。今天制造的大部分PC上面都带有「Intel Inside」标志这一事实，提醒着我们即使在商品的体系结构中也是有专有技术优势的机会的。
这些和开放源码软件都有什么关系呢？你可能会问。
我的前提是，免费和开放源码开发者在今天的境地，正如IBM在1981年改变了计算机行业的规则，却没能理解这一变革的后果时一样，让别人收割了果实。大部分现存的专有软件生产商境况也没好到哪去，在新的规则开始重塑它们周围的行业的时候，它们还在遵循着老的规则。
在我的演讲中，我用一个简单的测试，来检测我的计算机产业专业人士听众是在用旧的还是新的范式在思考问题。「你们有多少人用Linux®？」我问。依场合不同，20~80%的观众可能会举手。「你们有多少人用Google？」房间里的每个人都举手了。这时就看出端倪来了。他们中间每个人都在使用Google的巨大的100 000台Linux服务器的复合体，但是他们却觉得「你用的软件」就是你面前那台电脑运行的软件，而对答案视而不见。因特网上的绝大部分「杀手级应用」，那些被上亿人使用的应用程序，都在Linux或者FreeBSD上面运行。但是操作系统，如前所定义，对于这些应用程序而言只是更大的系统中的一部分。互联网才是真正的平台。
只有研究这些下一代应用，我们才能开始理解开放源码范式转移的真正长期重要性。
如果开放源码的先锋们要从我们刚刚释放出来的革命中获益，我们必须看透自由和开放源码运动的表面元素，更深刻地理解这一革命的原因和后果。
人工智能的先锋Ray Kurzweil曾经说过，「我是一个发明家。我对长期趋势更感兴趣，因为一项发明的意义存在于它结束的那个世界里，而不是它开始的那个世界里。」
我发现把开放源码表述成三个深刻、长期的趋势很有用：
 软件的商品化 基于网络的协作 软件的定制性（作为服务的软件）  像上面「3C」这样的长期趋势，而不是《自由软件宣言》或《开放源码定义》，才应该成为我们理解正在释放的诸多变革的透镜。
作为商品的软件 在《软件商品化的一些含义》一文中，Dave Stutz写道：
商品一词今天用来代表工业过程中的基本材料：即那些有价值的、多用途的基本构件。因为它们非常通用，它们经常以各种方式被大量使用。商品总是被超过一家生产商供应，消费者能用一家生产商的产品来替代另外一家的而不蒙受任何损失。因为商品的这种可替代性，它们都由其必须遵守的一致的质量标准来定义。这些质量标准有助于避免掺假，也有助于快速、简易的价值估算，进而促进了生产力的提高。
软件商品化是由标准驱动的，尤其是随着像互联网这样的面向通信的系统的兴起，其依赖于共享的协议，并定义了合作部件之间的而非内部的共享界面和数据类型。这样的系统必然由可替换的部件组成。像Apache或者微软的IIS这样的web服务器，或者像Internet Explorer, Netscape Navigator®，或Mozilla这样的浏览器，都是很容易相互替换的，因为要让它们能够工作，它们必须实现HTTP协议和HTML数据格式。Sendmail可以由Exim、Postfix或者微软Exchange替代，因为它们都必须支持像SMTP、POP、以及IMAP这样的邮件交换协议。微软Outlook®也能很容易地被Eudora®，或者Pine，或者Mozilla Mail，或者一个像Yahoo! Mail那样的web邮件客户端所替代。
（在这点上，值得一提的是Unix®，这个Linux®所基于的系统，也有一个以通信为中心的体系结构。在《Unix编程环境》一书中，Kernighan和Pike生动地描述了应该怎样把Unix程序写成一条「流水线」里面合作的小模块，读写ASCII文本文件，而非专有数据格式。Eric Reymond在他的《Unix编程艺术》一书中就此主题也给出了当代的表述。）
要注意，在一个拥有标准协议的以通信为中心的环境中，专有的和开放源码的软件都成为了商品。微软的Internet Explorer web浏览器和Apache web服务器一样都是商品，因为它们都受web开放标准的制约。（如果微软设法在web浏览器和web服务器之间协议流水线两端都获得了统治性的市场份额，那就是另外一个问题了！请参看我在tim.oreilly.com上《How the Web Was Almost Won》（《Web如何差点取胜》）一文中就此问题的讨论。这个例子清楚地表明了开放源码在「保持标准诚实」中扮演的重要角色。这个角色得到了像W3C这样的机构的认可，它们变得越发不愿意为专有的或者受专利所困恼的实现方式而背书了。）
更重要的是，即使是那些一开始就是专有的软件后来也变得标准化，并最终商品化了。Dave Stutz在一篇题为《软件平台的自然史》的文章中生动地描述了这个过程：
它发生在由平台提供的外壳的随着时间推移逐渐固化的过程中。随着一个平台在市场上成功，其API、用户界面、功能组、文件格式、和自定制界面开始固化并越发难以改变。（实际上，它们可能固化到一定程度以至于真的变成了硬件装置！）这一固化的过程使得成功的平台很容易成为复制者的目标，而复制也就吹响了平台利润开始终结的号角。
和这个观点一致，对微软的Windows®和Office产品的复制也是免费和开放源码社区的主要目标。在过去，微软通过不断修订其API和文件格式成功地挫败了一些复制企图，但是不祥之兆已经很明显。普及性带动了标准化，为了维护垄断而进行的无理由的发明只会被用户抛弃。</description>
    </item>
    
  </channel>
</rss>
